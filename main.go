package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/build"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/koron-go/srcdom"
	"golang.org/x/tools/imports"
)

type errs []error

func (e *errs) Append(err error) {
	*e = append(*e, err)
}

func (e errs) Error() string {
	if len(e) == 0 {
		return "no errors"
	}
	b := &strings.Builder{}
	fmt.Fprintln(b, "found some errors:")
	for i, err := range e {
		fmt.Fprintf(b, "#d - %v\n", i+1, err)
	}
	return b.String()
}

type variable struct {
	name string
	typ  string
}

type vars []*variable

func (vv *vars) add(v *variable) {
	*vv = append(*vv, v)
}

func (vv vars) nameTypes() string {
	return vv.join(func(v *variable) string {
		return v.name + " " + v.typ
	})
}

func (vv vars) names() string {
	return vv.join(func(v *variable) string {
		return v.name
	})
}

func (vv vars) namesPrefix(prefix string) string {
	return vv.join(func(v *variable) string {
		return prefix + "." + v.name
	})
}

func (vv vars) types() string {
	return vv.join(func(v *variable) string {
		return v.typ
	})
}

func (vv vars) join(fn func(v *variable) string) string {
	b := &strings.Builder{}
	for i, v := range vv {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(fn(v))
	}
	return b.String()
}

type method struct {
	typn string
	name string
	args vars
	rets vars
}

func (m *method) fullname() string {
	return m.typn + m.name
}

func vname(name string, attr string, n int) string {
	if name != "" {
		return name
	}
	return attr + strconv.Itoa(n)
}

func filterMethods(src []*srcdom.Func, typ *srcdom.Type) []*method {
	var dst []*method
	for _, f := range src {
		if !f.IsPublic() {
			continue
		}
		m := &method{typn: typ.Name, name: f.Name}
		for i, p := range f.Params {
			m.args.add(&variable{
				name: vname(p.Name, "in", i),
				typ:  p.Type,
			})
		}
		for i, r := range f.Results {
			m.rets.add(&variable{
				name: vname(r.Name, "out", i),
				typ:  r.Type,
			})
		}
		dst = append(dst, m)
	}
	return dst
}

func generateMockType0(w io.Writer, mocktag string, pkgname string, typ *srcdom.Type, pkg *srcdom.Package) error {
	methods := filterMethods(typ.Methods, typ)
	if len(methods) == 0 {
		return fmt.Errorf("no methods in type:%s", typ.Name)
	}
	origtyp := pkg.Name + "." + typ.Name
	fmt.Fprintf(w, "// +build %s\n\n", mocktag)
	fmt.Fprintf(w, "// Code generated by github.com/koron/mockgo; DO NOT EDIT.\n\n")
	fmt.Fprintf(w, "package %s\n\n", pkgname)

	fmt.Fprintf(w, "// %s is a mock of %s.%[1]s for test.\n", typ.Name, pkg.Name)
	fmt.Fprintf(w, "type %s struct {\n", typ.Name)
	for _, m := range methods {
		fmt.Fprintf(w, "\t%s_Ps []*%s_P\n", m.name, m.fullname())
		fmt.Fprintf(w, "\t%s_Rs []*%s_R\n", m.name, m.fullname())
	}
	fmt.Fprintf(w, "}\n")

	for _, m := range methods {
		fmt.Fprintf(w, "\n")
		fmt.Fprintf(w, "// %s_P packs input parameters of %s#%s method.\n", m.fullname(), origtyp, m.name)
		fmt.Fprintf(w, "type %s_P struct {\n", m.fullname())
		for _, a := range m.args {
			fmt.Fprintf(w, "\t%s %s\n", a.name, a.typ)
		}
		fmt.Fprintf(w, "}\n\n")
		fmt.Fprintf(w, "// %s_R packs output parameters of %s#%s method.\n", m.fullname(), origtyp, m.name)
		fmt.Fprintf(w, "type %s%s_R struct {\n", typ.Name, m.name)
		for _, r := range m.rets {
			fmt.Fprintf(w, "\t%s %s\n", r.name, r.typ)
		}
		fmt.Fprintf(w, "}\n\n")
		fmt.Fprintf(w, "// %s is mock of %s#%[1]s method.\n", m.name, origtyp)
		fmt.Fprintf(w, "func (_m *%s) %s(%s) (%s) {\n", typ.Name, m.name, m.args.nameTypes(), m.rets.types())
		fmt.Fprintf(w, "\t_m.%s_Ps = append(_m.%[1]s_Ps, &%s_P{%s})\n", m.name, m.fullname(), m.args.names())
		fmt.Fprintf(w, "\tvar _r *%[1]s%[2]s_R\n", typ.Name, m.name)
		fmt.Fprintf(w, "\t_r, _m.%[1]s_Rs = _m.%[1]s_Rs[0], _m.%[1]s_Rs[1:]\n", m.name)
		fmt.Fprintf(w, "\treturn %s\n", m.rets.namesPrefix("_r"))
		fmt.Fprintf(w, "}\n")
	}
	return nil
}

func path2pkgname(path string) (string, error) {
	p, err := filepath.Abs(path)
	if err != nil {
		return "", err
	}
	return filepath.Base(p), nil
}

func generateMockType(outdir string, applyFormat bool, typ *srcdom.Type, pkg *srcdom.Package) error {
	pkgn, err := path2pkgname(outdir)
	if err != nil {
		return err
	}

	fname := fmt.Sprintf("%s_mock.go", strings.ToLower(typ.Name))
	fpath := filepath.Join(outdir, fname)
	f, err := os.Create(fpath)
	if err != nil {
		return err
	}
	defer f.Close()
	bw := bufio.NewWriter(f)

	var w io.Writer = bw
	var bb *bytes.Buffer

	if applyFormat {
		bb = &bytes.Buffer{}
		w = bb
	}

	err = generateMockType0(w, "mock", pkgn, typ, pkg)
	if err != nil {
		f.Close()
		os.Remove(fpath)
		return err
	}

	if bb != nil {
		b, err := imports.Process(fname, bb.Bytes(), nil)
		if err != nil {
			f.Close()
			os.Remove(fpath)
			return err
		}
		bw.Write(b)
	}

	err = bw.Flush()
	if err != nil {
		f.Close()
		os.Remove(fpath)
		return err
	}
	err = f.Sync()
	if err != nil {
		f.Close()
		os.Remove(fpath)
		return err
	}
	err = f.Close()
	if err != nil {
		os.Remove(fpath)
		return err
	}
	return nil
}

func gen() error {
	var (
		pkgname  string
		outdir   string
		typnames []string
		noFormat bool
	)
	flag.StringVar(&pkgname, "package", "", `package name`)
	flag.StringVar(&outdir, "outdir", ".", `output directory`)
	flag.BoolVar(&noFormat, "noformat", false, `suppress to apply goimports`)
	flag.Parse()
	typnames = flag.Args()

	if pkgname == "" {
		return errors.New("need -package option")
	}
	if len(typnames) == 0 {
		return errors.New("need one or more type names")
	}

	path := filepath.Join(build.Default.GOPATH, "src", pkgname)
	pkg, err := srcdom.Read(path)
	if err != nil {
		return err
	}
	var errs errs
	for _, typn := range typnames {
		typ, ok := pkg.Type(typn)
		if !ok {
			err := fmt.Errorf("not found type:%s, skipped", typn)
			errs.Append(err)
			log.Print(err)
			continue
		}
		err := generateMockType(outdir, !noFormat, typ, pkg)
		if err != nil {
			err2 := fmt.Errorf("failed to generate mock for %s: %s", typ, err)
			errs.Append(err2)
			log.Print(err2)
			continue
		}
	}
	if len(errs) > 0 {
		return errs
	}
	return nil
}

func main() {
	err := gen()
	if err != nil {
		log.Fatal(err)
	}
}
